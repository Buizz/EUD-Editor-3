import SCAFlexible as scf;
import TriggerEditor.SCATool as sct;


const ArrayobjectN = 1000;
const Arraysize = 100;
const Arraybuffer = EUDArray(ArrayobjectN * Arraysize);
const Arrayoffset = EUDArray(py_list(py_range(0, 4 * Arraysize * ArrayobjectN, 4 * Arraysize)));

var Arrayremaining = ArrayobjectN;


function Arrayalloc(): EUDArray {
    Arrayremaining -= 1;
    return Arraybuffer + Arrayoffset[Arrayremaining];
}
function Arrayfree(array) {
    Arrayoffset[Arrayremaining] = array - Arraybuffer;
    Arrayremaining += 1;
}


const MiniArrayobjectN = 100;
const MiniArraysize = 10;
const MiniArraybuffer = EUDArray(MiniArrayobjectN * MiniArraysize);
const MiniArrayoffset = EUDArray(py_list(py_range(0, 4 * MiniArraysize * MiniArrayobjectN, 4 * MiniArraysize)));
var MiniArrayremaining = MiniArrayobjectN;


function MiniArrayalloc(): EUDArray {
    MiniArrayremaining -= 1;
    return MiniArraybuffer + MiniArrayoffset[MiniArrayremaining];
}
function MiniArrayfree(array) {
    MiniArrayoffset[MiniArrayremaining] = array - MiniArraybuffer;
    MiniArrayremaining += 1;
}



const st = StringBuffer();
object SCAReturnValue{
    var lastepd;

    //Number = 1
    //String = 2
    //Array = 3
    var valueType;

    var length;
    var value;
    var array : EUDArray;
    function constructor(type, epd){
        this.valueType = type;
        this.lastepd = epd;
    }

    function GetIndex(index) : selftype{
        return selftype.cast(this.array[index]);
    }

    function destructor(){
        if(this.valueType == 1){
            Arrayfree(this.value);
        }else if(this.valueType == 2){
            for(var i = 0 ; i < this.length ; i++){
                Arrayfree(this.array[i]);
            }
            Arrayfree(this.array);
        }
    }
};

function numberReturnFactory(rval : SCAReturnValue){
    rval.value = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd);
    rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;
}

function stringReturnFactory(rval : SCAReturnValue){
    rval.length = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd);
    rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;

    const array = Arrayalloc();
    for(var ai = 0; ai < rval.length; ai++){
        array[ai] = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd);
        rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;
    }
    rval.value = array;
}

function arrayReturnFactory3(rval : SCAReturnValue){
    rval.length = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd);
    rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;

    const array = Arrayalloc();
    for(var i = 0; i < rval.length; i++){
        const valuetype = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd); //변수 종류
        rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;

        const returnval = SCAReturnValue.alloc(valuetype, rval.lastepd);
        switch(valuetype){
            case 1: //Number = 1
                numberReturnFactory(returnval);
                break; 
            case 2: //String = 2
                stringReturnFactory(returnval);
                break;
            case 3: //Array = 3
                //arrayReturnFactory2(returnval);
                break;
        }

        array[i] = returnval;
        rval.lastepd = returnval.lastepd;
    }
    
    rval.value = array;
}

function arrayReturnFactory2(rval : SCAReturnValue){
    rval.length = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd);
    rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;

    const array = Arrayalloc();
    for(var i = 0; i < rval.length; i++){
        const valuetype = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd); //변수 종류
        rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;

        const returnval = SCAReturnValue.alloc(valuetype, rval.lastepd);
        switch(valuetype){
            case 1: //Number = 1
                numberReturnFactory(returnval);
                break; 
            case 2: //String = 2
                stringReturnFactory(returnval);
                break;
            case 3: //Array = 3
                arrayReturnFactory3(returnval);
                break;
        }

        array[i] = returnval;
        rval.lastepd = returnval.lastepd;
    }
    
    rval.value = array;
}

function arrayReturnFactory(rval : SCAReturnValue){
    rval.length = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd);
    rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;

    const array = Arrayalloc();
    for(var i = 0; i < rval.length; i++){
        const valuetype = dwread_epd(scf.FuncReturnTableEPD + rval.lastepd); //변수 종류
        rval.lastepd += 1; if (rval.lastepd >= scf.FuncLength) rval.lastepd = 0;

        const returnval = SCAReturnValue.alloc(valuetype, rval.lastepd);
        switch(valuetype){
            case 1: //Number = 1
                numberReturnFactory(returnval);
                break; 
            case 2: //String = 2
                stringReturnFactory(returnval);
                break;
            case 3: //Array = 3
                arrayReturnFactory2(returnval);
                break;
        }

        array[i] = returnval;
        rval.lastepd = returnval.lastepd;
    }
    
    rval.value = array;
}



object SCAReturn{
    //리턴을 여러개 받을 수 있음.
    //리턴을 받으면 값 삭제.
    
    var returnindex;
    var returncount;
    var returnvallist : EUDArray;
    var lastepd;

    function GetValue(index) : SCAReturnValue{
        return SCAReturnValue.cast(this.returnvallist[index]);
    }


    function constructor(epd){
        var tepd = epd;

        this.returnindex = dwread_epd(scf.FuncReturnTableEPD + tepd);
        tepd += 1; if (tepd >= scf.FuncLength) tepd = 0;

        this.returncount = dwread_epd(scf.FuncReturnTableEPD + tepd);
        tepd += 1; if (tepd >= scf.FuncLength) tepd = 0;
        this.returnvallist = MiniArrayalloc();

        var vindex = 0;
        for(var i = 0; i < this.returncount; i++){
            const valuetype = dwread_epd(scf.FuncReturnTableEPD + tepd); //변수 종류
            tepd += 1; if (tepd >= scf.FuncLength) tepd = 0;

            const returnval = SCAReturnValue.alloc(valuetype, tepd);
            switch(valuetype){
                case 1: //Number = 1
                    numberReturnFactory(returnval);
                    break;
                case 2: //String = 2
                    stringReturnFactory(returnval);
                    break;
                case 3: //Array = 3
                    arrayReturnFactory(returnval);
                    break;
            }

            this.returnvallist[i] = returnval;

            tepd = returnval.lastepd;
        }

        this.lastepd = tepd;
    }


    function destructor(){
        for(var i = 0; i < this.returncount; i++){
            const item = SCAReturnValue.cast(this.returnvallist[i]);
            SCAReturnValue.free(item);
        }
        MiniArrayfree(this.returnvallist);
    }
};

//리턴값 처리기
var lastepd = 0;
const returnarray = EUDArray(100);
function Exec(){
    if(!MemoryEPD(scf.FuncCommandEPD + 1, Exactly, lastepd)){
        const rtoken = SCAReturn.alloc(lastepd);

        const rindex = rtoken.returnindex;

        
        if(returnarray[rindex] != 0){
            //값이 존재하므로 free해준다.
             const item = SCAReturn.cast(returnarray[rindex]);
             SCAReturn.free(item);
             returnarray[rindex] = 0;
        }

        returnarray[rindex] = rtoken;
        
        //st.printf("returnindex : {}, argcount : {}", rtoken.returnindex, rtoken.returncount);
        //st.printf("{} {}", lastepd, rtoken.lastepd);

        lastepd = rtoken.lastepd;
    }
}


//리턴 성공 했는지 판단
function IsReturn(rindex){
    if(returnarray[rindex] != 0){
        return true;
    }else{
        return false;
    }
    
}

//리턴 값 초기화
function ResetReturnObject(rindex){
    if(returnarray[rindex] != 0){
        //값이 존재하므로 free해준다.
        const item = SCAReturn.cast(returnarray[rindex]);
        SCAReturn.free(item);
        returnarray[rindex] = 0;
    }
}

//리턴 오브젝트 반환
function GetReturnObject(rindex) : SCAReturn{
    return returnarray[rindex];
}

